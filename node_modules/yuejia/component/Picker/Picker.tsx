import yj from '../../typings';
import * as React from 'react';
import Item, { Base as ItemBase , Data, itemHeight, num, Value } from './Item';
import ObArray from '../../app/datatype/obArray';
import './index.scss';

export interface Base extends ItemBase {
  /** 在onScollEnd后触发，用于判断哪些列需要保持原来的选中索引，哪些列需要初始化为0 */
  formatSelectedCol?: (currentCol: number, selectedItem: SelectedItem[]) => number[];
  /** 是否级联 */
  cascade?: boolean;
}

export interface Props extends yj.ComponentProps, Base {
  /** 当是级联的时候是一维数组，否则是对象二维数组 */
  data: ObArray<Data> | ObArray<Data[]>;
  value: Value[] | undefined;
  onScrollEnd: (currentCol: number, currentValue: Value, selectedIndex: number, allValue: Value[]) => void;
  /** 组件创建成功后执行 */
  onCreate?: (data: Data[][]) => void;
}

export type SelectedItem = (number | undefined);

interface State {
  selectedindex: SelectedItem[];
  data: Data[][];
  lastDataId: number;
}

interface FormatData {
  selectedindex: SelectedItem[];
  data: Data[][];
}

const prefixCls = 'yj-component-picker';

/** 获取被选中的列的子项选中的索引 */
function getSelectedColIndex(selectedItem: SelectedItem[], col: number): number {
  const selectedIndex = selectedItem[col];
  return selectedIndex ? selectedIndex : 0;
}

/** 设置格式化后的数据 */
function formatData(selectedColIndex: SelectedItem[], stateData: Data[][], data: Data[], startCol: number = 0): FormatData {
  const selectedItem: SelectedItem[] = selectedColIndex;
  const newData: Data[][] = stateData;
  const each = (eachData: Data[]) => {
    // 判断数据是否为空
    if (eachData === undefined || (eachData.length === 0)) {
      return;
    } else {
      const selectedIndex = getSelectedColIndex(selectedColIndex, startCol);
      let selectedData = eachData[selectedIndex] as Data | undefined;

      // 如果selectedData不存在就取索引为0的数据
      if (selectedData === undefined) {
        selectedItem[startCol] = 0;
        selectedData = eachData[0];
      }
      const children = selectedData.children;
      newData[startCol] = [];

      for (let i = 0; i < eachData.length; i++) {
        newData[startCol].push(eachData[i]);
      }
      startCol++;
      each(children as Data[]);
    }
  };

  // 如果是第一列就先初始化
  if (startCol === 0) {
    newData[0] = [];
    for (let i = 0; i < data.length; i++) {
      const dataitem = data[i];
      const selectedIndex = getSelectedColIndex(selectedColIndex, 0);
      newData[0].push(dataitem);

      // 找到第一列被选中的项，把他的children拿去递归
      if (selectedIndex === i && dataitem.children) {
        startCol++;
        each(dataitem.children);
      }
    }
  } else {
    each(newData[startCol]);
  }

  return {
    data: newData,
    selectedindex: selectedItem
  };
}

/** 根据是否是级联，来确定是否要格式化数据 */
function switchData(props: Props, selectedColIndex: SelectedItem[], stateData: Data[][], startCol: number): FormatData {
  if (props.cascade) {
    const propsData = props.data.get() as Data[];
    return formatData(selectedColIndex, stateData, propsData, startCol);
  } else {
    return {
      data: props.data.get() as Data[][],
      selectedindex: selectedColIndex
    };
  }
}

class Picker extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);

    const selectedIndex = [];
    if (this.props.value) {
      for (let i = 0; i < this.props.value.length; i++) {
        selectedIndex[i] = this.props.value[i].index;
      }
    }

    this.state = {
      // 初始化数据
      ...switchData(props, selectedIndex, [], 0),
      lastDataId: 0
    };
  }

  public state: State;
  // /** 滚动条选择的项 */
  // private selectedIndex: SelectedItem[] = [];
  // private data: Data[][] = [];

  public componentDidMount(): void {
    if (this.props.onCreate) {
      this.props.onCreate(this.state.data as Data[][]);
    }
  }

  public static getDerivedStateFromProps(nextProps: Props, prevState: State): State | null {
    const nextDataId = nextProps.data.getDataId();
    if (prevState.lastDataId !== nextDataId) {
      return {
        ...switchData(nextProps, prevState.selectedindex, prevState.data, 0),
        lastDataId: nextDataId
      };
    }

    return null;
  }

  /** 滚动结束后 */
  private onScrollEnd(currentCol: number, currentValue: Value, selectedIndex: number): void {
    const { formatSelectedCol, cascade, onScrollEnd } = this.props;
    const allValue = [];
    let selectedIndexTemp = this.state.selectedindex;
    // 先更新到最新的值
    selectedIndexTemp[currentCol] = selectedIndex;

    if (formatSelectedCol) {
      selectedIndexTemp = formatSelectedCol(currentCol, selectedIndexTemp);
    } else if (cascade) {
      // 将currentCol后续的列初始化为0，重置子项列表的选中项
      for (let i = currentCol + 1; i < this.state.data.length; i++) {
        selectedIndexTemp[i] = 0;
      }
    }

    const result = switchData(this.props, selectedIndexTemp, this.state.data, currentCol);

    for (let i = 0; i < result.data.length; i++) {
      const index = result.selectedindex[i] || 0;
      const item = (result.data as Data[][])[i][index];
      allValue.push({
        label: item.label,
        value: item.value,
        index
      });
    }

    onScrollEnd(currentCol, currentValue, selectedIndex, allValue);
    this.setState({
      ...result
    });
  }

  public render(): JSX.Element {
    const { className, id, style, itemCls, textCls } = this.props;
    const value = this.props.value;
    const data = this.state.data as Data[][];
    const dataId = this.props.data.getDataId();

    return (
      <div
        className={className}
        id={id}
        style={style}
      >
        <div className={`${prefixCls}-panel`}>
          <div className={`${prefixCls}-mask`} style={{ backgroundSize: `100% ${itemHeight * num}px` }} />
          <div className={`${prefixCls}-indicator`} style={{ top: `${itemHeight * num}px` }} />
          <div className={`${prefixCls}-content`}>
            {data.map((item, col) => (
              <Item
                key={col}
                data={item}
                dataId={dataId}
                value={value ? value[col] : item[col]}
                itemCls={itemCls}
                textCls={textCls}
                onScrollEnd={(currentValue, index) => this.onScrollEnd(col, currentValue, index)}
                selectedIndex={getSelectedColIndex(this.state.selectedindex, col)}
              />
            ))}
          </div>
        </div>
      </div>
    );
  }
}

export default Picker;