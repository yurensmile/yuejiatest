import yj from '../../typings';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import isPassiveSupported from '../../utils/isPassiveSupported';
import elementHasScroll from '../../utils/elementHasScroll';

interface ItemRef {
  [key: string]: HTMLDivElement | null;
}

export interface Data {
  [key: string]: {
    label: string;
    value: string | number;
  }[];
}

export interface Props extends yj.ComponentProps {
  /** 显示的数据 */
  data: Data;
  /** 列表项的渲染函数 */
  itemRender: (key: string, index: number) => JSX.Element;
  /** 索引块的渲染函数 */
  indexRender: (key: string, index: number) => any;
  /** 包裹列表项的样式 */
  itemCls?: string;
  /** 包裹索引块的样式 */
  indexCls?: string;
  /** 索引块列表项的样式 */
  indexItemCls?: string;
  /** 数据更新id，用来判断是否要触发更新 */
  dataUpdateId?: any;
  /** 是否使用自定义索引列表渲染 */
  customIndexRender?: boolean;
}

class IndexList extends React.Component<Props> {
  constructor(props: Props) {
    super(props);

    this.saveIndexRef = this.saveIndexRef.bind(this);
    this.saveElemRef = this.saveElemRef.bind(this);
    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);
    this.onClick = this.onClick.bind(this);
  }

  private id: string = Date.now().toString();
  private elemRef!: HTMLDivElement | null;
  private itemRef: ItemRef = {};
  private indexRef!: HTMLDivElement | null;
  /** 索引孔每一项的高度 */
  private indexItemHeight: number = 0;
  /** 开始的pageY */
  private startPageY: number = 0;
  /** 开始的索引 */
  private startIndex: number = 0;
  /** data的keys */
  private keys: string[] = [];
  private hasScoll: boolean = false;

  public componentDidMount(): void {
    if (this.indexRef) {
      const willPreventDefault = isPassiveSupported ? { passive: false } : false;
      this.indexRef.addEventListener('touchstart', this.onTouchStart);
      this.indexRef.addEventListener('touchmove', this.onTouchMove, willPreventDefault);
    }

    // 初始化item相关的数据
    if (this.itemRef) {
      this.init();
    }

    if (this.elemRef) {
      this.hasScoll = elementHasScroll(this.elemRef);
    }
  }

  public componentWillUnmount(): void {
    if (this.indexRef) {
      this.indexRef.removeEventListener('touchmove', this.onTouchMove);
      this.indexRef.removeEventListener('touchstart', this.onTouchStart);
    }
    this.removeContainer();
  }

  public componentDidUpdate(prevProps: Props): void {
    if (this.props.dataUpdateId !== prevProps.dataUpdateId) {
      this.itemRef = {};

      if (this.elemRef) {
        this.hasScoll = elementHasScroll(this.elemRef);
      }
    }
    // 初始化数据
    if (this.itemRef) {
      this.init();
    }
  }

  private init(): void {
    if (this.indexRef && this.indexRef.children.length) {
      this.indexItemHeight = (this.indexRef.children[0]).clientHeight;
    }
  }

  private onTouchStart(e: HTMLElementEventMap['touchstart']): void {
    const event = e as TouchEvent;
    const target = event.target as HTMLDivElement;
    this.startPageY = event.touches[0].clientY;
    this.startIndex = parseInt(target.dataset['index'] || '');
  }

  private onTouchMove(e: HTMLElementEventMap['touchmove']): void {
    const event = e as TouchEvent;
    event.preventDefault();

    const pageY = event.touches[0].clientY;
    const delta = Math.round((pageY - this.startPageY) / this.indexItemHeight);
    let index = this.startIndex + delta;
    // 边界处理
    if (index < 0) {
      index = 0;
    } else if (index >= this.keys.length) {
      index = this.keys.length - 1;
    }

    const itemElem = this.itemRef[this.keys[index]] as HTMLDivElement;
    if (itemElem) {
      const top = itemElem.offsetTop;

      this.scrollTo(top);
    }
  }

  private onClick(e: React.MouseEvent<HTMLDivElement>): void {
    const key = (e.target as HTMLDivElement).innerText;
    const itemElem = this.itemRef[key];

    if (itemElem) {
      const top = itemElem.offsetTop;

      this.scrollTo(top);
    }
  }

  private scrollTo(top: number): void {
    if (this.elemRef && this.hasScoll) {
      this.elemRef.scrollTop = top;
    } else {
      window.scrollTo(0, top);
    }
  }

  private saveIndexRef(el: HTMLDivElement | null): void {
    this.indexRef = el;
  }

  private saveElemRef(el: HTMLDivElement | null): void {
    this.elemRef = el;
  }

  private getContainer(): HTMLDivElement {
    let container = document.getElementById(this.id) as HTMLDivElement;
    if (!container) {
      container = document.createElement('div');
      container.setAttribute('id', this.id);
      document.body.appendChild(container);
    }
    return container;
  }

  public removeContainer(): void {
    const container = document.getElementById(this.id) as HTMLElement;
    if (container && container.parentNode) {
      container.parentNode.removeChild(container);
    }
  }

  public render(): JSX.Element {
    const { className, style, id, data, itemRender, indexRender, itemCls, indexCls, indexItemCls, customIndexRender } = this.props;
    this.keys = Object.keys(data);
    const IndexRender = (
      <div
        className={indexCls}
        ref={this.saveIndexRef}
        onClick={this.onClick}
      >
        {this.keys.map((item, i) => (
          <div className={indexItemCls} key={item + i} data-index={i}>{indexRender(item, i)}</div>
        ))}
      </div>
    );

    return (
      <div className={className} style={style} id={id} ref={this.saveElemRef}>
        {customIndexRender ? IndexRender : null}
        {this.keys.map((key, i) => (
          <div
            className={itemCls}
            key={key}
            ref={(el) => this.itemRef[key] = el}
          >
            {itemRender(key, i)}
          </div>
        ))}
        {customIndexRender ? null : ReactDOM.createPortal(IndexRender, this.getContainer())}
      </div>
    );
  }
}

export default IndexList;