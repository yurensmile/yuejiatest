import yj from '../../typings';
import * as React from 'react';
import * as classNames from 'classnames';
import * as BetterScroll from 'better-scroll';
import getNumberByComputed from '../../utils/getNumberByComputed';
import './index.scss';

export interface Props extends yj.ComponentProps {
  children: JSX.Element[] | JSX.Element;
  /** 用于自动移动到被查询到的元素位置上 */
  query?: string;
}

interface State {
  /** 容器的宽度 */
  width: number | string;
}

const BScroll = (BetterScroll as any).default as BScrollStatic;
const prefixCls = 'yj-component-horizontalscroll';
class HorizontalScroll extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);

    this.elemRef = React.createRef();
    this.wrapRef = React.createRef();
    this.onClick = this.onClick.bind(this);
  }

  private elemRef: React.RefObject<HTMLDivElement>;
  private wrapRef: React.RefObject<HTMLDivElement>;
  private scroll!: BScroll;
  /** 上一次容器的宽度 */
  private prevFrameWidth!: number | string;

  public state: State = {
    width: 'inherit'
  };

  public componentDidMount(): void {
    this.init();
  }

  public componentDidUpdate(): void {
    const width = this.calcFrameWidth();

    if (this.props.query) {
      this.autoMove(this.props.query);
    }
    // 如果dom更新后的宽度和之前的宽度不一致就刷新scroll
    if (this.scroll && this.prevFrameWidth && width && this.prevFrameWidth !== width) {
      this.prevFrameWidth = width;
      this.setState({
        width
      }, () => {
        this.scroll.refresh();
      });
    }
  }

  public componentWillUnmount(): void {
    if (this.scroll) {
      this.scroll.destroy();
    }
  }

  private init(): void {
    const width = this.calcFrameWidth();

    if (width) {
      this.prevFrameWidth = width;
      this.setState({
        width
      }, () => {
        this.scroll = new BScroll(this.elemRef.current as HTMLDivElement, {
          scrollX: true,
          scrollY: false,
          bindToWrapper: true,
          eventPassthrough: 'vertical'
        });
      });
    }
  }

  /** 计算容器的宽度 */
  private calcFrameWidth(): number {
    let frameWidth = 0;
    if (this.wrapRef.current) {
      const children = this.wrapRef.current.children;

      for (let i = 0; i < children.length; i++) {
        children[i].classList.add(`${prefixCls}-item`);
        const width = getNumberByComputed(getComputedStyle(children[i]).width);
        const marginLeft = getNumberByComputed(getComputedStyle(children[i]).marginLeft);
        const marginRight = getNumberByComputed(getComputedStyle(children[i]).marginRight);
        frameWidth += width + marginLeft + marginRight;
      }
    }

    return frameWidth;
  }

  /** 自动移动滚动条横坐标 */
  private autoMove(query: string): void {
    const elem = document.querySelector('.' + query);

    if (elem && this.scroll) {
      const offsetLeft = (elem as HTMLDivElement).offsetLeft;
      const marginLeft = getNumberByComputed(getComputedStyle(elem).marginLeft);
      const x = -offsetLeft + marginLeft;
      this.scroll.scrollTo(x, 0);
    }
  }

  private onClick(e: React.MouseEvent<HTMLDivElement>): void {
    e.preventDefault();
    e.stopPropagation();
  }

  public render(): JSX.Element {
    const { className, style, children } = this.props;

    return (
      <div
        className={classNames(prefixCls, className)}
        style={style}
        ref={this.elemRef}
        onClick={this.onClick}
      >
        <div
          className={`${prefixCls}-wrap`}
          ref={this.wrapRef}
          style={{
            width: this.state.width,
          }}
        >{children}</div>
      </div>
    );
  }
}

export default HorizontalScroll;