import { Type as StateType } from '../../../StateMachine';
import SaveRequest from './save';
import ObObject from '../../../../app/datatype/obObject';
import { ReadOnly } from '../../../../_base/datatype';

interface LocalValue {
  result: BMap.GeocoderResult;
  timestamp: number;
}

interface Event {
  callback?: (gr: BMap.GeocoderResult) => void;
  failback?: () => void;
}

export interface OnGeolocationParams extends Event {
  timeout?: number;
}

export interface Address {
  /** 省 */
  province: string;
  /** 市 */
  city: string;
  provinceId?: string | number;
  cityId?: string | number;
}

interface Props {
  /** 储存坐标的aoi */
  saveApi?: string;
  /** 默认值，默认为百度地图定位结果 */
  value?: Address;
  /** 定位失败后的值 */
  failAddress?: Address;
  onGeolocation?: OnGeolocationParams;
}

class Geolocation {
  constructor(props?: Props) {
    this.address = new ObObject({ defaultValue: props && props.value });

    if (props) {
      this.failAddress = props.failAddress;

      if (props.onGeolocation) {
        this.callback = props.onGeolocation.callback;
        this.failback = props.onGeolocation.failback;

        if (props.onGeolocation.timeout) {
          this.timeout = props.onGeolocation.timeout;
        }
      }

      if (props.saveApi) {
        this.saveRquest = new SaveRequest({
          api: props.saveApi
        });
      }
    }

    this.cancel = this.cancel.bind(this);
    this.setValue = this.setValue.bind(this);
    this.getValue = this.getValue.bind(this);
    this.location = this.location.bind(this);
    this.geocoderToAddress = this.geocoderToAddress.bind(this);
  }
  /** 定位结果 */
  private value: ObObject<BMap.GeocoderResult | undefined> = new ObObject({ defaultValue: undefined });
  /** 储存的时间：默认6小时 */
  private maximum: number = 1000 * 60 * 60 * 1;
  /** 定位是否被取消 */
  private canceled: boolean = false;
  /** 定位锁，防止重复发起定位, 为true是锁住，为false未锁住 */
  private lock: boolean = false;
  /** 定时器 */
  private timer: NodeJS.Timer | number | undefined;
  /** 读取本地缓存 */
  private get cache(): LocalValue | undefined {
    const local = localStorage.getItem('geolocation');
    if (local && typeof BMap !== 'undefined') {
      try {
        const parse = JSON.parse(local) as LocalValue;
        const point = parse.result.point;

        if (point) {
          parse.result.point = new BMap.Point(point.lng, point.lat);
          this.locationResult = parse.result;
          return parse;
        }
      } catch (err) {
        console.warn('getGeocoderResult解析localStorage数据，请检查数据格式是否正确', err);
      }
    }
  }
  /** 缓存是否过期 */
  private get expired(): boolean {
    const local = this.cache;

    // 为true表示过期
    return local ? local.timestamp - Date.now() <= 0 : true;
  }
  /** 定位成功的回调 */
  public callback?: Event['callback'];
  /** 定位失败的回调 */
  public failback?: Event['failback'];
  /** 定位超时的时间 */
  public timeout: number = 5000;
  /** 存储坐标的请求 */
  public readonly saveRquest: SaveRequest | undefined;
  /** 定位状态 */
  public readonly state: ObObject<StateType> = new ObObject({ defaultValue: undefined });
  /** 省市 */
  public readonly address: ObObject<Address | undefined>;
  /** 失败后显示的省市 */
  public failAddress: Address | undefined;
  /** 定位结果，定位改变才会改变 */
  public locationResult: BMap.GeocoderResult | undefined;

  /** 定位事件 */
  private onLocation(): void {
    const geolocation = new BMap.Geolocation();
    const gc = new BMap.Geocoder();
    this.lock = true;

    this.state.set('loading');
    geolocation.getCurrentPosition((result) => {
      if (geolocation.getStatus() === BMAP_STATUS_SUCCESS) {
        gc.getLocation(result.point, (gr) => {
          if (gr) {
            gr.point = result.point;
            try {
              localStorage.setItem('geolocation', JSON.stringify({
                result: gr,
                timestamp: Date.now() + this.maximum
              }));
            } catch (err) {
              console.error('localStorage.setItem失败，请检查数据格式是否正确', err);
            }
            this.setValue(gr);
            this.locationResult = gr;
          } else {
            this.locationResult = undefined;
            this.locationFail();
            this.cancel();
            if (this.failback) {
              this.failback();
            }
            console.warn('定位失败');
          }
        });
      } else {
        this.locationFail();
        this.cancel();
        if (this.failback) {
          this.failback();
        }
        console.warn('取消定位');
      }
    }, { enableHighAccuracy: true, maximumAge: this.maximum });
  }

  /** 定位失败后的处理 */
  private locationFail(): void {
    this.address.set(this.failAddress);
    this.state.set('fail');
  }

  private setValue(value: BMap.GeocoderResult): void {
    // 防止离开页面后调用回调
    if (this.canceled === false) {
      this.lock = false;
      this.value.set(value);
      this.address.set(this.geocoderToAddress(value));
      this.state.set('complete');

      if (this.callback) {
        this.callback(value);
      }

      if (this.saveRquest) {
        this.saveRquest.send(value);
      }
    }
  }
  public getValue(): ReadOnly<BMap.GeocoderResult> | undefined {
    return this.value.get() || (this.cache && this.cache.result);
  }

  /** 取消定位 */
  public cancel(): void {
    this.canceled = true;
    this.lock = false;
    if (this.timer) {
      clearTimeout(this.timer as number);
    }
  }

  /** 定位动作, cache: 是否使用缓存 */
  public location(useCache?: boolean): void {
    const _useCache = useCache === false ? false : this.expired === false;
    // 重置定位取消状态
    this.canceled = false;

    // 如果锁住，就不在定位
    if (this.lock) {
      return;
    }

    // 缓存过期或不存在缓存就调用定位
    if (_useCache === false) {
      this.onLocation();
      // 判断定时到期后有没有获取到值，没有获取到值就取消定位
      this.timer = setTimeout(() => {
        if (this.getValue() === undefined) {
          this.locationFail();
          if (this.failback) {
            this.failback();
          }
          this.cancel();
        }
        // 默认定时5秒
      }, this.timeout);
    } else {
      // 防止离开页面后调用回调
      const cache = this.cache;
      if (cache) {
        this.setValue(cache.result);
      }
    }
  }

  /** 定位结果转地址 */
  public geocoderToAddress(gr: BMap.GeocoderResult): Address {
    return {
      province: gr.addressComponents.province,
      city: gr.addressComponents.city
    };
  }
}

export default Geolocation;