import Fields from '../../_base/service/fields';
import Toast from '../Toast';
import Request from '../../app/request';
import ObArray from '../../app/datatype/obArray';
import ObObject from '../../app/datatype/obObject';

interface Options {
  request?: Request;
}

export interface Params {
  [key: string]: any;
}

class Form {
  constructor(options: Options) {
    this.request = options.request;

    this.submit = this.submit.bind(this);
  }

  /** 提交的请求 */
  public readonly request: Request | undefined;
  /** 要提交的字段 */
  public readonly fields: ObArray<Fields<any>> = new ObArray();
  /** 表单是否已触发 */
  public readonly trigger: ObObject<boolean> = new ObObject({ defaultValue: false });
  /** 表单是否在可提交状态 */
  public get complete(): boolean {
    const fileds = this.fields.get();
    for (let i = 0; i < fileds.length; i++) {
      const filed = fileds[i];

      if (filed.state !== 'complete') {
        return false;
      }
    }

    return true;
  }

  // @action public validate(fieldKey: string | undefined, submit: boolean, callback?: (field: Fields<any>) => void): void {
  //   let isComplete: boolean = true;
  //   // 是否触发了callback
  //   let isTriggerCallbcak = false;

  //   for (let i = 0; i < this.fields.length; i++) {
  //     const filed = this.fields[i];

  //     // 排除fileds调用getForm().validate时，对自身的验证
  //     // 并且只验证非正确的，getError !== false表示非正确
  //     if (fieldKey !== filed.fieldKey && filed.getError() !== false) {
  //       // filed.getError() === undefined和filed.getValue() === undefined表示为初始值，
  //       // 当error和value都是初始值且必选为true时，就忽略这个验证，为的是防止一个filed时输入完成时会引发其他还没输入的
  // tslint:disable-next-line:max-line-length
  //       const ignore = filed.getError() === undefined && filed.getValue() === undefined && filed.getRequired() === true && submit === false;
  //       if (ignore === false) {
  //         this.fields[i].validate();
  //       }
  //     }

  //     // 有一次验证没通过，整个表单就属于未完成状态
  //     // 为了防止isComplete被后面验证通过的值覆盖掉，所以仅在为true（初始值）时才去验证
  //     if (isComplete) {
  //       // 因为前面对filed.getError()为undefined进行过判断，所以这里不会为undefined
  //       // 因为this.fields[i].validate()调用后可能会改变filed.getError()的值，所以要重新调用一次，不能去做缓存
  //       isComplete = filed.getError() === false;
  //     }

  //     // isTriggerCallbcak只调用一次
  //     if (isTriggerCallbcak === false && callback && isComplete === false) {
  //       callback(this.fields[i]);
  //       isTriggerCallbcak = true;
  //     }
  //   }

  //   this.complete = isComplete;
  // }
  /**
   * 显示字段的错误提示
   * 同时只触发一个Toast
   */
  public showPrompt(): void {
    const fileds = this.fields.get();
    for (let i = 0; i < fileds.length; i++) {
      const filed = fileds[i];

      if (filed.state !== 'complete') {
        Toast.show(filed.getPrompt());
        return;
      }
    }
  }

  public submit(params?: Params): void {
    if (this.complete) {
      if (this.request && this.request.state.get() !== 'loading') {
        this.trigger.set(false);
        this.request.state.set('loading');
        this.request.send(params);
      } else {
        console.warn('submit缺少request属性，不能发送请求');
      }
    } else {
      this.trigger.set(true);
      this.showPrompt();
    }
  }
}

export default Form;