import yj from '../../typings';
import * as React from 'react';
import * as classNames from 'classnames';
import './index.scss';

interface Props extends yj.ComponentProps {
  /** 阈值 */
  top: number;
  /** 状态改变时调用，isOver: 是否超过设置的top值 */
  onChange: (isOver: boolean) => void;
  children?: any;
}
interface State {
}

const prefixCls = 'yj-component-sticky';
class Sticky extends React.Component<Props, State> {
  constructor(props: Props, state: State) {
    super(props, state);

    this.setSticky = this.setSticky.bind(this);
    this.elemRef = React.createRef();
  }

  /** 是否超过设置的top值 */
  private isOver: boolean | undefined;
  private elemRef: React.RefObject<HTMLDivElement>;

  /** 设置是否触发粘性 */
  private setSticky(): void {
    const top = window.scrollY || (this.elemRef.current && this.elemRef.current.scrollTop) || 0;
    const isOver = top >= this.props.top;

    // 判断状态是否发生变化
    if (isOver !== this.isOver) {
      this.props.onChange(isOver);
    }

    this.isOver = isOver;
  }

  public componentDidMount(): void {
    // 初始化时调用一次，防止初始化时滚动条不在顶部
    this.setSticky();
    if (this.elemRef.current) {
      this.elemRef.current.addEventListener('scroll', this.setSticky);
    }
  }

  public componentWillUnmount(): void {
    if (this.elemRef.current) {
      this.elemRef.current.removeEventListener('scroll', this.setSticky);
    }
  }

  public render(): JSX.Element {
    const { className, children, style } = this.props;

    return (
      <div
        className={classNames(prefixCls, className)}
        ref={this.elemRef}
        style={style}
      >
        {children}
      </div>
    );
  }
}

export default Sticky;
