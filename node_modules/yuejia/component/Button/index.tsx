import yj from '../../typings';
import * as React from 'react';
import * as classNames from 'classnames';
import { Type } from '../StateMachine';
import sheet, { getActionName } from '../../model/behavior/sheet';
import PageStack from '../PageStack';
import './index.scss';

export interface Props extends yj.ComponentProps, yj.ComponentBehavior  {
  children?: any;
  disabled?: boolean;
  htmlType?: 'submit' | 'button';
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void;
  shadow?: boolean;
  /** 表单是否处于完成状态 */
  complete?: boolean;
  state?: Type;
  /** 倒计时最大时间 */
  countdown?: number;
  /** 自定义渲染倒计时的文本 */
  countdownFormat?: (countdown: number) => any;
}

interface State {
  backgroundColor: string;
  /** 按钮文本 */
  label: any;
  didUpdateId: number;
  lastChildren: any;
  lastComplete: boolean | undefined;
}

const prefixCls = 'yj-component-button';
class Button extends React.Component<Props, State> {
  constructor(props: Props, state: State) {
    super(props, state);

    this.buttonRef = React.createRef();
    this.onClick = this.onClick.bind(this);
  }

  public state: State = {
    backgroundColor: '',
    label: this.props.children,
    didUpdateId: 0,
    lastChildren: this.props.children,
    lastComplete: this.props.complete
  };

  private buttonRef: React.RefObject<HTMLButtonElement>;
  /** 计数，用于倒计时 */
  private countup: number = this.props.countdown || 0;
  /** 计数定时器 */
  private countTimer: NodeJS.Timer | number | undefined;

  public componentDidMount(): void {
    this.setBackgroundColor();
  }

  public static getDerivedStateFromProps(nextProps: Props, prevState: State): State | null {
    if (nextProps.complete !== prevState.lastComplete) {
      return {
        ...prevState,
        didUpdateId: prevState.didUpdateId + 1,
        label: nextProps.children !== prevState.lastChildren ? nextProps.children : prevState.label,
        lastChildren: nextProps.children,
        lastComplete: nextProps.complete,
      };
    }

    return null;
  }

  public componentDidUpdate(prevProps: Props, prevState: State): void {
    const backgroundColorChange = prevState.backgroundColor !== this.state.backgroundColor;
    const didUpdateChange = prevState.didUpdateId !== this.state.didUpdateId;

    if (backgroundColorChange || didUpdateChange) {
      this.setBackgroundColor();
    }
  }

  private setBackgroundColor(): void {
    if (this.props.shadow) {
      if (this.buttonRef.current) {
        let backgroundColor = getComputedStyle(this.buttonRef.current).backgroundColor as string;

        if (backgroundColor) {
          backgroundColor = this.rgb2rgba(backgroundColor);
        }
        this.setState({
          backgroundColor
        });
      }
    }
  }

  private rgb2rgba(rgb: string): string {
    if (rgb.indexOf('rgba') > 0) {
      return rgb;
    } else {
      const temp = rgb.replace('rgb(', '').replace(')', '').split(',');
      const r = temp[0];
      const g = temp[1];
      const b = temp[2];

      return `rgba(${r},${g},${b}, 0.5)`;
    }
  }

  private onClick(e: React.MouseEvent<HTMLButtonElement>): void {
    const { countdown, onClick, complete } = this.props;
    const stackComponent = PageStack.getStackComponent();

    if (stackComponent && this.props.componentName) {
      stackComponent.behavior.trigger({
        actionName: getActionName(sheet.Button, 0, this.props)
      });
    }

    if (onClick) {
      onClick(e);
    }

    if (complete !== true) {
      return;
    }

    // 如果倒计时存在就会进入倒计时模式
    if (countdown !== undefined) {
      this.setLabel(true);
      this.countTimer = setInterval(() => {
        if (this.countup === 0) {
          this.countup = countdown;
          clearInterval(this.countTimer as NodeJS.Timer);
          this.setLabel(false);
        } else {
          this.setLabel(true);
        }
      }, 1000);
    }
  }

  /** 设置按钮文本，countup：是否计数 */
  private setLabel(countup: boolean): void {
    const { countdownFormat, countdown } = this.props;
    let label: any;
    if (countup) {
      this.countup--;
    }

    // tslint:disable-next-line:prefer-conditional-expression
    if (this.countup !== countdown) {
      label = countdownFormat ? countdownFormat(this.countup) : `${this.props.children}(${this.countup})`;
    } else {
      label = this.props.children;
    }

    this.setState({ label });
  }

  public render(): JSX.Element {
    const props = this.props;
    const {
      className, style, htmlType, shadow, complete, state, datatype, countdown
    } = props;
    const disabled = props.disabled || state === 'loading' || (countdown !== undefined && this.countup !== countdown);

    return (
      <button
        className={classNames(prefixCls, className, {
          [`${prefixCls}-preparation`]: complete === false && htmlType === 'submit',
        })}
        ref={this.buttonRef}
        style={{
          boxShadow: shadow ? `3px 3px 12px ${this.state.backgroundColor}` : undefined,
          ...style,
        }}
        type={htmlType || 'button'}
        disabled={disabled}
        onClick={this.onClick}
        data-type={datatype}
      >
        {this.state.label}
      </button>
    );
  }
}

export default Button;
