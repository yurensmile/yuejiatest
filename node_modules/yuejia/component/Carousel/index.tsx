import yj from '../../typings';
import * as React from 'react';
import * as classNames from 'classnames';
import * as BetterScroll from 'better-scroll';
import Slide, { BaseProps as SlideProps } from './Slide';
import Dots from './Dots';
import device from '../../utils/device';
import getDirection from '../../utils/getDirection';
import './index.scss';

export interface BaseProps extends yj.ComponentProps, SlideProps {
  /** 单个slide宽度 */
  slideWidth?: number;
  /** 是否开启圆点 */
  dots?: boolean;
  /** 是否自动轮播 */
  autoplay?: boolean;
  /** 自动间隔时间 */
  interval?: number;
  /** 滑动后触发的事件 */
  onAfterSlide?: (index: number, direction: 'prev' | 'next', isAuto: boolean) => void;
  /** 是否开启滑动，默认为true */
  swiping?: boolean;
}

export interface Props extends BaseProps {
  /** 当前的索引 */
  index: number;
  /** 数据的id，用来判断数据是否发生变化 */
  dataId: any;
  /** 用于判断是否是手动指定跳转 */
  goToPageId?: any;
}

interface State {
  dataId: any;
  /** 是否处于卸载状态 */
  unmount: boolean;
}

const prefixCls = 'yj-component-carousel';
const BScroll = (BetterScroll as any).default as BScrollStatic;

class Carousel extends React.Component<Props> {
  constructor(props: Props) {
    super(props);

    this.slideRef = React.createRef();
    this.init = this.init.bind(this);
    this.onBeforeSlide = this.onBeforeSlide.bind(this);
    this.onAfterSlide = this.onAfterSlide.bind(this);
  }

  public static defaultProps: Props = {
    index: 0,
    interval: 3000,
    swiping: true,
    dataId: 0,
    goToPageId: 0
  };

  public state: State = {
    dataId: this.props.dataId,
    unmount: false
  };

  private slideRef: React.RefObject<HTMLDivElement>;
  private slide!: BScroll;
  private timer: NodeJS.Timer | number | undefined;
  /** 动画执行时间 */
  private speed: number = 400;
  /** 是否是自动轮播触发的滑动 */
  private slideIsAuto: boolean = false;
  /** 总slide数量 */
  private get slideCount(): number {
    let count = React.Children.count(this.props.children);

    if (count === 1) {
      React.Children.forEach(this.props.children, (child) => {
        const childElem = child as React.ReactElement<any>;
        if (childElem.props.data) {
          count = childElem.props.data.length;
        }
      });
    }

    return count;
  }

  public componentDidMount(): void {
    this.init();
  }

  public static getDerivedStateFromProps(nextProps: Props, prevState: State): State | null {
    if (nextProps.dataId !== prevState.dataId) {
      return {
        dataId: nextProps.dataId,
        unmount: true
      };
    }

    return null;
  }

  public componentDidUpdate(prevProps: Props): void {
    const dataId = this.props.dataId;
    const prevDataId = prevProps.dataId;

    // 数据发生变化
    if (dataId !== prevDataId && this.slideRef.current) {
      this.slide.destroy();
      this.setState({
        unmount: false
      }, this.init);
    } else if (this.props.index !== prevProps.index) {
      if (this.props.goToPageId !== prevProps.goToPageId) {
        this.slide.goToPage(this.props.index, 0);
      } else {
        this.slide.goToPage(this.props.index, 0, 0);
      }
    }

    // 更新是否可以滑动的状态
    if (this.props.swiping !== prevProps.swiping) {
      if (this.props.swiping === true) {
        this.slide.enable();
      } else {
        this.slide.disable();
      }
    }

    // 更新是否可以自动轮播的状态
    if (this.props.autoplay !== prevProps.autoplay) {
      this.autoplay(this.props);
    }
  }

  public componentWillUnmount(): void {
    if (this.timer) {
      clearTimeout(this.timer as number);
    }

    if (this.slide) {
      this.slide.destroy();
    }
  }

  private init(): void {
    if (this.slideRef.current) {
      this.slide = new BScroll(this.slideRef.current, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        click: true,
        snap: {
          loop: this.props.loop,
          threshold: 0.1,
          speed: this.speed
        },
        bounce: false,
      });

      if (this.props.index !== 0) {
        this.slide.goToPage(this.props.index, 0, 0);
      }
      this.slide.on('scrollEnd', this.onAfterSlide);
      this.slide.on('beforeScrollStart', this.onBeforeSlide);
      this.slide.on('touchEnd', () => {
        this.autoplay(this.props);
      });

      if (this.props.swiping === false) {
        this.slide.disable();
      }

      // 初始化自动轮播
      this.autoplay(this.props);
    }

  }

  private onBeforeSlide(): void {
    if (this.props.autoplay && this.timer) {
      clearTimeout(this.timer as number);
    }
  }

  private onAfterSlide(): void {
    // 当前索引
    const nowIndex = this.slide.getCurrentPage().pageX;
    // 上一个索引，因为还没给state更新值
    // const prevIndex = this.state.index;
    const prevIndex = this.props.index;
    // 最后一个索引，因为索引是从0开始计算，总slide数量是从1开始计算，所以要-1
    const lastIndex = this.slideCount - 1;
    // slide滑动的方向，通过计算索引差值来实现
    const direction = getDirection(nowIndex, prevIndex, lastIndex);

    this.setState({
      index: nowIndex
    }, () => {
      this.autoplay(this.props);
    });

    // 索引变化时才触发滑动后的事件
    if (this.props.onAfterSlide && nowIndex !== prevIndex) {
      this.props.onAfterSlide(nowIndex, direction, this.slideIsAuto);
    }

    // 还原初始化状态
    this.slideIsAuto = false;
  }

  /** 自动轮播 */
  private autoplay(props: Props): void {
    if (props.autoplay) {
      if (this.timer) {
        clearTimeout(this.timer as number);
      }

      // 自动轮播
      this.timer = setTimeout(() => {
        this.slideIsAuto = true;
        this.slide.next();
      }, this.props.interval);
    }
  }

  public render(): JSX.Element {
    const { className, children, style, slideWidth, loop, dots, slideHeight, index } = this.props;
    const width = slideWidth || device.width;

    return (
      <div
        className={classNames(prefixCls, className)}
        style={{
          width,
          ...style
        }}
        ref={this.slideRef}
      >
        {this.state.unmount === false ? (
          <Slide
            className={className}
            style={style}
            slideWidth={width}
            loop={loop}
            slideCount={this.slideCount}
            slideHeight={slideHeight}
          >{children}</Slide>
        ) : null}
        {dots ? (
          // <Dots activeIndex={this.state.index} count={this.slideCount} />
          <Dots activeIndex={index} count={this.slideCount} />
        ) : null}
      </div>
    );
  }
}

export default Carousel;