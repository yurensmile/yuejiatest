import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
import createSourceFile from '../behavior/createSourceFile';
// @ts-ignore
import writeLog from '../behavior/writeLog';
import getExportDefault from '../behavior/getExportDefault';
import eachNode from '../behavior/eachNode';
import { JsxElementNode } from '../behavior/findJsxElement';
import { createDirByFilePath } from '../create/dir';

function replaceIdentifier(text: string, start: number, end: number, replaceText: string): string {
  const before = text.substr(0, start);
  const after = text.substr(end);
  return before + replaceText + after;
  // console.log('start--- ')
  // console.log();
  // console.log('before pos:', childNode.pos)
  // console.log(before);
  // console.log();
  // console.log('identifier:')
  // console.log(identifier)
  // console.log();
  // console.log('after:')
  // console.log(after);
  // console.log();
  // console.log('code:')
  // console.log(newCode)
  // console.log('---end')
  // console.log();
}

function eachJsx(code: string): string {
  let isOver = false;

  while (isOver === false) {
    const source = ts.createSourceFile('', code, 6, false, 4);
    let stop = false;
    for (let i = 0; i < source.statements.length; i++) {
      if (stop) {
        break;
      }
      const statement = source.statements[i];

      eachNode(statement, (childNode) => {
        if (stop === false) {
          // fs.writeFileSync(`./sourcefile/${l}.log`, stringify(childNode), { encoding: 'utf8' });
          if (childNode.kind === ts.SyntaxKind.JsxAttribute) {
            // 1.替换wx:这类的特殊关键字
            // 2.获取属性值的文字并改写成小程序的写法
            const identifier = (childNode as ts.JsxAttribute).name as ts.Identifier;
            const attrValue = (childNode as ts.JsxAttribute).initializer;
            const text = identifier.text;

            if (text.indexOf('$wx_') >= 0) {
              code = replaceIdentifier(code, identifier.pos, identifier.end, text.replace('$wx_', '  wx:'));
            } else if (text.indexOf('_') > 0) {
              code = replaceIdentifier(code, identifier.pos, identifier.end, text.replace('_', '-'));
            }

            if (attrValue && attrValue.kind === ts.SyntaxKind.JsxExpression) {
              const valueText = code.substr(attrValue.pos, attrValue.end - attrValue.pos);
              code = replaceIdentifier(code, attrValue.pos, attrValue.end, `"{${valueText}}"`);
              stop = true;
            }
          } else if (childNode.kind === ts.SyntaxKind.ExpressionStatement) {
            // 对children节点的表达式增加一层花括号
            const s = childNode.pos;
            const e = childNode.end;

            if (code[s - 1] === '{' && code[e] === '}' && code[s - 2] !== '{' && code[e - 1] !== '}') {
              const valueText = code.substr(s, e - s);
              code = replaceIdentifier(code, s, e, `{${valueText}}`);
              stop = true;
            }
          }
        }
      });
    }

    if (stop === false) {
      isOver = true;
    }
  }

  return code;
}

function replaceWxPorps(node: JsxElementNode['node'], code: string): string {
  const codeSplit = code.split('\r\n');
  let newCode = '';

  codeSplit.forEach((item, i) => {
    // 开标签和闭合标签大写转小写
    for (let j = 0; j < item.length; j++) {
      const charCode = item.charCodeAt(j);
      if (
        charCode >= 65 && charCode <= 90 &&
        (item[j - 1] === '/' && item[j - 2] === '<') ||
        (item[j - 1] === '<') ||
        (item[j - 1] === '-')
      ) {
        item = replaceIdentifier(item, j, j + 1, item[j].toLocaleLowerCase());
      } else if (item[j] === '_') {
        const nextChar = item[j + 1];
        const nextCharCode = nextChar ? item.charCodeAt(j + 1) : -1;

        // 防止误伤样式对象
        if (nextCharCode >= 65 && nextCharCode <= 90) {
          item = replaceIdentifier(item, j, j + 1, '-');
        }
      }
    }

    item = eachJsx(item);
    newCode += item;
  });

  // console.log(newCode);
  return newCode;
}

export default function tsx2wxml(filePath: string): void {
  const source = createSourceFile(`./src/${filePath}.tsx`);
  const text = source.getText();
  const exportDefault = getExportDefault(source);

  // console.log('filepath:', `./src/${filePath}.tsx`, exportDefault && exportDefault.expression.kind === ts.SyntaxKind.JsxElement)
  // writeLog('log', source);
  // 获取导出部分的代码
  if (exportDefault && exportDefault.expression && exportDefault.expression.kind === ts.SyntaxKind.JsxElement) {
    const node = exportDefault.expression as JsxElementNode['node'];
    const code = text.substr(node.pos, node.end - node.pos);
    const newCode = replaceWxPorps(node, code);
    const fileName = filePath.replace(`${path.sep}view`, `${path.sep}index`);

    // console.log(newCode)
    createDirByFilePath(`./dist/${filePath}`);
    fs.writeFileSync(`./dist/${fileName}.wxml`, newCode, { encoding: 'utf8' });
  }
}